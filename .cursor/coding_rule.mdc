---
alwaysApply: true
---
---
type: "agent_requested"
description: "Example description"
---

# General Coding Standards

## Core Principle: Code Readability

**ALWAYS write code that is self-explanatory and readable at a glance.**

### Code Readability Rules:

These rules apply to every programming language. Always follow the idioms of whichever language you are writing—naming styles, documentation formats, module organization, and more. When you are unsure about a convention, **query Context7 MCP for that language** to confirm current best practices before you commit to an approach.

1. **Use descriptive names that match the language convention** – Function, method, and class names must communicate intent while respecting the language’s casing rules (e.g., Python `calculate_progress_percentage`, Java `calculateProgressPercentage`, Rust `calculate_progress_percentage`). If the naming style is unclear, confirm it with Context7.

2. **Break down complex operations into helpers** – Replace long inline expressions with named helpers that suit the language (free functions, private methods, extension functions, etc.). For example, extract percentage math into a helper function rather than repeating the arithmetic inline.

3. **Centralize common operations in utilities** – Group shared math, string, date, or IO helpers using the language’s preferred structure (modules in Python, packages in Java, utility namespaces in C#, etc.). Reuse those helpers instead of rewriting low-level logic.

4. **Choose expressive variable names** – Select names that reveal purpose and respect the language’s style (`estimated_minutes_per_step` in Python, `estimatedMinutesPerStep` in Java, `estimatedMinutesPerStep` in TypeScript). Abbreviations are acceptable only when they are standard in that ecosystem.

5. **Isolate responsibilities inside small units** – Decompose large functions into smaller pieces with single responsibilities, using the constructs that feel idiomatic for the language (private helper functions, inner classes, traits, mixins, and so forth). Name each piece clearly so the call sites read like documentation.

6. **Document behaviors with language-appropriate comments** – Add structured documentation using the target language’s format (Python docstrings, Javadoc, Rust `///` doc comments, Go doc comments, etc.). Include purpose, parameters, return values, and notable edge cases. Use Context7 to double-check the correct syntax when switching languages.

7. **Organize code by responsibility in a familiar order** – Place public APIs or entry points first, then internal helpers, keeping utilities in their own modules or files when that’s customary for the language. Follow any additional ordering guidance surfaced via Context7.

### Testing Rules:

8. **Always parameterize tests** - Use test parameterization to cover multiple scenarios:
   ```typescript
   describe.each([
     ['valid input', 'test@example.com', true],
     ['invalid input', 'invalid-email', false],
     ['empty input', '', false],
     ['null input', null, false]
   ])('validateEmail with %s', (description, input, expected) => {
     it(`should return ${expected}`, () => {
       expect(validateEmail(input)).toBe(expected);
     });
   });
   ```

9. **Follow TDD (Test-Driven Development) approach**:
   - **ALWAYS create test file first** before implementing any new file
   - Write comprehensive test cases that describe the expected behavior and use cases
   - Create template tests that cover all scenarios and edge cases
   - Only then implement the actual logic/function to make tests pass
   - This ensures complete test coverage and validates the design before implementation

10. **Explain file purpose before implementation**:
    - **ALWAYS explain exactly what a file does** before writing any code
    - Describe the file's responsibility, inputs, outputs, and behavior
    - Outline the key methods/functions and their purposes
    - Explain how it fits into the overall architecture
    - This ensures clear understanding and prevents scope creep

### Error Handling and Type Safety:

11. **Handle edge cases gracefully**:
    - Always check for null/undefined values
    - Use optional chaining (`?.`) and nullish coalescing (`??`)
    - Provide meaningful error messages

12. **Use TypeScript strictly**:
    - Avoid `any` type - use proper interfaces and types
    - Enable strict mode in tsconfig.json
    - Use union types for better type safety

### Composer/Plan Mode - Epic & Task Documentation:

13. **ALWAYS Follow Epic/Task Documentation Structure in Plan Mode**:
   
   When developing a new feature in Composer/Plan Mode:
   
   **Step 1: User provides Epic Name and Task Number+Name**
   - Example: Epic: "User Authentication", Task: "001-login-flow"
   
   **Step 2: Check if Epic directory exists**
   - Look for `.cursor/tasks/[epic_name]/` directory
   
   **Step 3: Create Epic directory if it doesn't exist**
   - Create `.cursor/tasks/[epic_name]/` using kebab-case
   - Example: `.cursor/tasks/user-authentication/`
   
   **Step 4: Create Task subdirectory**
   - Inside epic directory, create `[task_number]-[task_name]/` directory
   - Example: `.cursor/tasks/user-authentication/001-login-flow/`
   
   **Step 5: Create documentation files inside task directory**
   - `[task_number]-[task_name]_plan.mdc` - Created BEFORE implementation
   - `[task_number]-[task_name]_summary.mdc` - Created AFTER implementation
   
   **Complete Structure:**
   ```
   .cursor/
   └── tasks/
       └── [epic_name]/                           # e.g., user-authentication
           └── [task_number]-[task_name]/         # e.g., 001-login-flow
               ├── [task_number]-[task_name]_plan.mdc      # e.g., 001-login-flow_plan.mdc
               └── [task_number]-[task_name]_summary.mdc   # e.g., 001-login-flow_summary.mdc
   ```

14. **Plan Document Structure (`*_plan.mdc`)**:
   ```markdown
   # [Task Number] - [Task Name]
   
   **Epic:** [Epic Name]
   **Created:** [Date]
   **Status:** Planning
   
   ## Overview
   - Brief description of the task
   - Problem it solves
   - User story / Use case
   
   ## Architecture
   - Components affected
   - New files to create
   - Files to modify
   - Dependencies required
   
   ## Implementation Steps
   1. Step-by-step breakdown
   2. Order of implementation
   3. Testing strategy for each step
   
   ## API Changes (if applicable)
   - New endpoints
   - Modified endpoints
   - Request/Response schemas
   
   ## Testing Strategy
   - Unit tests required
   - Integration tests required
   - Manual testing steps
   
   ## Success Criteria
   - How to verify the feature works
   - Performance metrics
   - Acceptance criteria
   ```

15. **Summary Document Structure (`*_summary.mdc`)**:
   ```markdown
   # [Task Number] - [Task Name] - Implementation Summary
   
   **Epic:** [Epic Name]
   **Completed:** [Date]
   **Status:** Completed
   
   ## What Was Implemented
   - List of files created/modified
   - Actual implementation vs. plan
   
   ## Deviations from Plan
   - Any changes made during implementation
   - Reasons for deviations
   
   ## Testing Results
   - Unit test results
   - Integration test results
   - Manual testing outcome
   
   ## Lessons Learned
   - What went well
   - What could be improved
   - Technical debt introduced (if any)
   
   ## Next Steps
   - Follow-up tasks
   - Related tasks
   ```

16. **ALWAYS Create Plan Document FIRST**:
   - Before writing any code, create the `*_plan.mdc` file
   - Get user approval on the plan before implementation
   - Update plan if requirements change

17. **ALWAYS Create Summary Document LAST**:
   - After implementation is complete, create `*_summary.mdc`
   - Document actual results vs. planned approach
   - Include lessons learned and next steps

### Problem-Solving and UI Testing Rules:

22. **Use Playwright for UI Testing and Validation**:
   - **ALWAYS use Playwright MCP** for testing browser extension functionality
   - Test authentication flows, user interactions, and API integrations
   - Validate CORS handling and cross-origin communication
   - Test error states and user feedback mechanisms
   - Use screenshots and snapshots for visual regression testing

23. **UI Testing Best Practices**:
   - Test all user flows: registration, login, walkthrough requests
   - Validate error handling and user feedback
   - Test responsive behavior across different screen sizes
   - Verify accessibility features and keyboard navigation
   - Test cross-browser compatibility (Chrome, Firefox, Safari)

24. **Use Context7 MCP for Code Quality and Best Practices**:
   - **ALWAYS use Context7 MCP** to verify code quality and ensure up-to-date practices
   - Check library documentation for latest APIs and recommended patterns
   - Validate implementation approaches against current best practices
   - Ensure proper usage of frameworks, libraries, and tools
   - Reference official documentation for accurate method signatures and parameters
   - Use Context7 to stay current with evolving standards and deprecations

### When writing code, ALWAYS ask yourself:
- "Is this code self-explanatory?"
- "Would someone new to the codebase understand this immediately?"
- "Can I break this down into smaller, more descriptive functions?"
- "Are my variable and function names descriptive enough?"
- "Have I written comprehensive parameterized tests first?"
- "Do I understand exactly what this file should do?"
- "How can I test this UI functionality with Playwright?"
- "Should I use Context7 MCP to verify this implementation is following current best practices?"

### Remember: Code is read much more often than it is written. Write for the reader, not just for the compiler.
